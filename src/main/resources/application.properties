# ===============================
# APPLICATION CONFIGURATION
# ===============================
# Application name shown in logs and actuator
spring.application.name=Spring Boot JWT Security Application

# Server port - default is 8080
server.port=8080

# ===============================
# DATABASE CONFIGURATION (H2)
# ===============================
# H2 is an in-memory database perfect for learning
# Data is lost when application stops (use file-based or external DB in production)

# JDBC URL for H2 database
# - jdbc:h2:mem:securitydb creates an in-memory database named 'securitydb'
# - DB_CLOSE_DELAY=-1 keeps database open until JVM exits
# - DB_CLOSE_ON_EXIT=FALSE prevents automatic close on exit
spring.datasource.url=jdbc:h2:mem:securitydb

# Database driver class
spring.datasource.driver-class-name=org.h2.Driver

# Database credentials (default H2 credentials)
spring.datasource.username=sa
spring.datasource.password=

# ===============================
# JPA / HIBERNATE CONFIGURATION
# ===============================
# JPA (Java Persistence API) is the standard for ORM in Java
# Hibernate is the implementation we're using

# Database dialect - tells Hibernate what SQL variant to use
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# DDL (Data Definition Language) auto mode
# - create-drop: Creates schema on startup, drops on shutdown (good for learning/testing)
# - update: Updates schema if needed, doesn't drop (better for development)
# - validate: Only validates schema, doesn't make changes (production)
# - none: Disables automatic schema management (production with migration tools)
spring.jpa.hibernate.ddl-auto=create-drop

# Show SQL queries in console (great for learning!)
# Set to false in production for performance
spring.jpa.show-sql=true

# Format SQL queries for readability
spring.jpa.properties.hibernate.format_sql=true

# ===============================
# H2 WEB CONSOLE CONFIGURATION
# ===============================
# H2 Console is a web interface to view/query your database
# Access it at: http://localhost:8080/h2-console

# Enable H2 web console
spring.h2.console.enabled=true

# Console URL path
spring.h2.console.path=/h2-console

# ===============================
# JWT CONFIGURATION
# ===============================
# Custom properties for JWT token management

# JWT Secret Key
# IMPORTANT: This should be a strong, random secret key
# - Must be at least 256 bits (32 bytes) for HS256 algorithm
# - In production: Use environment variables or secure vault (never hardcode!)
# - This key is used to sign and verify JWT tokens
# - Anyone with this key can create valid tokens, so keep it SECRET!
jwt.secret=MySecretKeyForJWTTokenGenerationAndValidationMustBeAtLeast256BitsLong

# JWT Expiration Time (in milliseconds)
# - 86400000 ms = 24 hours
# - After this time, the token becomes invalid and user must login again
# - Shorter time = more secure but less convenient
# - Typical values: 15 min to 24 hours depending on security requirements
jwt.expiration=86400000

# ===============================
# LOGGING CONFIGURATION
# ===============================
# Configure logging levels for different packages
# Levels: TRACE < DEBUG < INFO < WARN < ERROR < FATAL

# Root logging level (applies to all packages)
logging.level.root=INFO

# Spring Security logging (set to DEBUG to see authentication details)
logging.level.org.springframework.security=DEBUG

# Your application logging
logging.level.com.security.jwt=DEBUG

# Hibernate logging (uncomment to debug database queries)
# logging.level.org.hibernate.SQL=DEBUG
# logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# ===============================
# SECURITY NOTES
# ===============================
# 1. JWT Secret: In production, NEVER hardcode the secret key
#    - Use environment variable: jwt.secret=${JWT_SECRET}
#    - Or use Spring Cloud Config, HashiCorp Vault, AWS Secrets Manager, etc.
#
# 2. Password Encoding: We use BCrypt to hash passwords
#    - Never store passwords in plain text
#    - BCrypt is one-way encryption (can't be decrypted)
#
# 3. HTTPS: In production, ALWAYS use HTTPS
#    - JWT tokens in HTTP headers can be intercepted
#    - Enable SSL/TLS in application.properties or reverse proxy
#
# 4. CORS: Configure Cross-Origin Resource Sharing if frontend is on different domain
#
# 5. Token Expiration: Balance security vs user experience
#    - Shorter expiration = more secure
#    - Implement refresh tokens for better UX
